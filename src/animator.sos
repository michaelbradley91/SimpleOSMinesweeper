/*
 * This file contains logic for updating animated parts of the game
 */

#include "src/memory_map.sos"
#include "src/assets.sos"
#include "src/coordinates.sos"

// Animation parameters
#constant RADAR_ANIMATION_FRAME_COUNT 0x4400
#constant RADAR_ANIMATION_FRAME_DURATION_MILLISECONDS 0x4401
#constant CLOCK_ANIMATION_FRAME_COUNT 0x4402
#constant CLOCK_ANIMATION_FRAME_DURATION_MILLISECONDS 0x4403

#constant ANIMATOR_TEMP_1 0x4404
#constant ANIMATOR_TEMP_2 0x4405
#constant ANIMATOR_TEMP_3 0x4406
#constant ANIMATOR_TEMP_4 0x4407
#constant ANIMATOR_TIME_START_MILLISECONDS 0x4408
#constant ANIMATOR_ELAPSED_SECONDS 0x4409
#constant ANIMATOR_TEMP_5 0x440a
#constant ANIMATOR_TEMP_FRAME 0x440b
#constant ANIMATOR_TEMP_RADAR_FRAME 0x440c
#constant ANIMATOR_TEMP_CLOCK_FRAME 0x440d
#constant ANIMATOR_SMILE_PRESSED 0x440e

// Get the right frame to show for an animation based on the number of ticks that have passed
#template_begin GET_ANIMATION_FRAME(TGT, FRAME_DURATION_MILLISECONDS, FRAME_COUNT, TICKS)
copy ANIMATOR_TEMP_1 TICKS
div ANIMATOR_TEMP_1 FRAME_DURATION_MILLISECONDS
copy ANIMATOR_TEMP_1 RETURN
mod ANIMATOR_TEMP_1 FRAME_COUNT
copy TGT RETURN
#template_end

// Update the radar sprite based on the number of ticks that have passed
#template_begin UPDATE_RADAR_ANIMATION()
get_ticks
GET_ANIMATION_FRAME(ANIMATOR_TEMP_FRAME, RADAR_ANIMATION_FRAME_DURATION_MILLISECONDS, RADAR_ANIMATION_FRAME_COUNT, RETURN)

GET_RADAR_ANIMATION_FRAME(ANIMATOR_TEMP_RADAR_FRAME, ANIMATOR_TEMP_FRAME)

draw RADAR_RECT ANIMATOR_TEMP_RADAR_FRAME
#template_end

#template_begin UPDATE_CLOCK_ANIMATION()
// Get the elapsed time in milliseconds
get_ticks
sub RETURN ANIMATOR_TIME_START_MILLISECONDS
GET_ANIMATION_FRAME(ANIMATOR_TEMP_FRAME, CLOCK_ANIMATION_FRAME_DURATION_MILLISECONDS, CLOCK_ANIMATION_FRAME_COUNT, RETURN)
GET_CLOCK_ANIMATION_FRAME(ANIMATOR_TEMP_CLOCK_FRAME, ANIMATOR_TEMP_FRAME)
draw CLOCK_RECT ANIMATOR_TEMP_CLOCK_FRAME
#template_end

// Update the smiley face
#template_begin UPDATE_SMILE()
eq ANIMATOR_SMILE_PRESSED ONE
JUMP_COND(RETURN, update_smile_end:f)

// Are we still playing?
neq GAME_RESULT GAME_CONTINUE
JUMP_COND(RETURN, update_smile_skip_continue:f)
draw FACE_RECT SPRITE_HAPPYSMILE
JUMP(update_smile_end:f)

update_smile_skip_continue:

// Did we lose?
neq GAME_RESULT GAME_LOSE
JUMP_COND(RETURN, update_smile_skip_lose:f)
draw FACE_RECT SPRITE_UNHAPPYSMILE
JUMP(update_smile_end:f)

update_smile_skip_lose:

// We won!!
draw FACE_RECT SPRITE_WINSMILE

update_smile_end:
nop
#template_end

// Update the number of mines remaining in the top of the screen
#template_begin UPDATE_MINE_COUNT(COUNT)

// If the count is less than zero, show zero
gte COUNT ZERO
JUMP_COND(RETURN, update_mine_count_fill:f)

GET_SPRITE_FOR_DIGIT(ANIMATOR_TEMP_1, ZERO)
draw MINES_DIGIT_1_RECT ANIMATOR_TEMP_1
draw MINES_DIGIT_2_RECT ANIMATOR_TEMP_1
draw MINES_DIGIT_3_RECT ANIMATOR_TEMP_1

JUMP(update_mine_count_end:f)

update_mine_count_fill:
// Break up the count into digits
mod COUNT TEN
copy ANIMATOR_TEMP_1 RETURN
div COUNT TEN
mod RETURN TEN
copy ANIMATOR_TEMP_2 RETURN
div COUNT ONE_HUNDRED
mod RETURN TEN
copy ANIMATOR_TEMP_3 RETURN

// Now store each digit
GET_SPRITE_FOR_DIGIT(ANIMATOR_TEMP_4, ANIMATOR_TEMP_3)
draw MINES_DIGIT_1_RECT ANIMATOR_TEMP_4

GET_SPRITE_FOR_DIGIT(ANIMATOR_TEMP_4, ANIMATOR_TEMP_2)
draw MINES_DIGIT_2_RECT ANIMATOR_TEMP_4

GET_SPRITE_FOR_DIGIT(ANIMATOR_TEMP_4, ANIMATOR_TEMP_1)
draw MINES_DIGIT_3_RECT ANIMATOR_TEMP_4

update_mine_count_end:
nop
#template_end

// Update the timer by the clock
#template_begin UPDATE_TIMER()
// Get the elapsed time in seconds
get_ticks
sub RETURN ANIMATOR_TIME_START_MILLISECONDS
div RETURN ONE_THOUSAND
copy ANIMATOR_ELAPSED_SECONDS RETURN

// If the time is more than 9999 seconds, just show the max... (I doubt I'll test this...)
lt ANIMATOR_ELAPSED_SECONDS TEN_THOUSAND
JUMP_COND(RETURN, update_timer_fill:f)

GET_SPRITE_FOR_DIGIT(ANIMATOR_TEMP_1, NINE)
draw CLOCK_DIGIT_1_RECT ANIMATOR_TEMP_1
draw CLOCK_DIGIT_2_RECT ANIMATOR_TEMP_1
draw CLOCK_DIGIT_3_RECT ANIMATOR_TEMP_1
draw CLOCK_DIGIT_4_RECT ANIMATOR_TEMP_1

JUMP(update_timer_end:f)

// Now split it across the clock...
update_timer_fill:
mod ANIMATOR_ELAPSED_SECONDS TEN
copy ANIMATOR_TEMP_2 RETURN
GET_SPRITE_FOR_DIGIT(ANIMATOR_TEMP_1, ANIMATOR_TEMP_2)
draw CLOCK_DIGIT_4_RECT ANIMATOR_TEMP_1

// Divide by 10 and go again...
div ANIMATOR_ELAPSED_SECONDS TEN
copy ANIMATOR_ELAPSED_SECONDS RETURN
mod ANIMATOR_ELAPSED_SECONDS TEN
copy ANIMATOR_TEMP_2 RETURN
GET_SPRITE_FOR_DIGIT(ANIMATOR_TEMP_1, ANIMATOR_TEMP_2)
draw CLOCK_DIGIT_3_RECT ANIMATOR_TEMP_1

div ANIMATOR_ELAPSED_SECONDS TEN
copy ANIMATOR_ELAPSED_SECONDS RETURN
mod ANIMATOR_ELAPSED_SECONDS TEN
copy ANIMATOR_TEMP_2 RETURN
GET_SPRITE_FOR_DIGIT(ANIMATOR_TEMP_1, ANIMATOR_TEMP_2)
draw CLOCK_DIGIT_2_RECT ANIMATOR_TEMP_1

div ANIMATOR_ELAPSED_SECONDS TEN
copy ANIMATOR_ELAPSED_SECONDS RETURN
mod ANIMATOR_ELAPSED_SECONDS TEN
copy ANIMATOR_TEMP_2 RETURN
GET_SPRITE_FOR_DIGIT(ANIMATOR_TEMP_1, ANIMATOR_TEMP_2)
draw CLOCK_DIGIT_1_RECT ANIMATOR_TEMP_1

update_timer_end:
nop
#template_end

JUMP_COND(INCLUDE_ANIMATOR, animator_end:f)
copy INCLUDE_ANIMATOR ONE

// Play a radar frame every 70 milliseconds
store RADAR_ANIMATION_FRAME_COUNT 8
store RADAR_ANIMATION_FRAME_DURATION_MILLISECONDS 100

// Play a clock animation every 5 seconds
store CLOCK_ANIMATION_FRAME_COUNT 12
store CLOCK_ANIMATION_FRAME_DURATION_MILLISECONDS 5000

#template_begin UPDATE_ANIMATIONS()
UPDATE_RADAR_ANIMATION()
UPDATE_SMILE()

// If the game has been won or lost, don't update the clock
neq GAME_RESULT GAME_CONTINUE
JUMP_COND(RETURN, update_animations_end:f)
UPDATE_CLOCK_ANIMATION()
UPDATE_TIMER()
update_animations_end:
#template_end

#template_begin INIT_ANIMATIONS()
get_ticks
copy ANIMATOR_TIME_START_MILLISECONDS RETURN
UPDATE_MINE_COUNT(GRID_MINES_REMAINING)
UPDATE_SMILE()
#template_end

store ANIMATOR_SMILE_PRESSED 0
UPDATE_ANIMATIONS()
animator_end:
nop
